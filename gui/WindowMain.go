/**
 * Part of Wingows - Win32 API layer for Go
 * https://github.com/rodrigocfd/wingows
 * This library is released under the MIT license.
 */

package gui

import (
	"unsafe"
	"wingows/co"
	"wingows/gui/wm"
	"wingows/win"
)

var (
	globalUiFont = Font{} // created in RunAsMain(), freed in runMainLoop()
)

// Main application window.
// Allows message and notification handling.
type WindowMain struct {
	windowBase
	setup            windowMainSetup
	modelessChildren []win.HWND
	childPrevFocus   win.HWND // when window is inactivated
}

// Exposes parameters that will be used to create the window.
func (me *WindowMain) Setup() *windowMainSetup {
	if me.windowBase.Hwnd() != 0 {
		panic("Cannot change setup after the window was created.")
	}
	me.setup.initOnce() // guard
	return &me.setup
}

// Creates the main window and runs the main application loop.
func (me *WindowMain) RunAsMain() int32 {
	if win.IsWindowsVistaOrGreater() {
		win.SetProcessDPIAware()
	}
	win.InitCommonControls()

	me.setup.initOnce() // guard
	hInst := win.GetModuleHandle("")
	me.windowBase.registerClass(me.setup.genWndClassEx(hInst))

	globalUiFont.CreateUi() // create global font to be applied everywhere

	me.defaultMessageHandling()

	cxScreen := win.GetSystemMetrics(co.SM_CXSCREEN) // retrieve screen size
	cyScreen := win.GetSystemMetrics(co.SM_CYSCREEN)

	_, _, cx, cy := globalDpi.multiply(0, 0, me.setup.Width, me.setup.Height)

	me.windowBase.createWindow("WindowMain", me.setup.ExStyle,
		me.setup.ClassName, me.setup.Title, me.setup.Style,
		cxScreen/2-int32(cx)/2, cyScreen/2-int32(cy)/2, // center window on screen
		cx, cy, nil, me.setup.HMenu, hInst)

	me.windowBase.Hwnd().ShowWindow(me.setup.CmdShow)
	me.windowBase.Hwnd().UpdateWindow()

	return me.runMainLoop()
}

func (me *WindowMain) defaultMessageHandling() {
	me.windowBase.OnMsg().WmNcDestroy(func() {
		win.PostQuitMessage(0)
	})

	me.windowBase.OnMsg().WmSetFocus(func(p wm.SetFocus) {
		if me.windowBase.Hwnd() == win.GetFocus() {
			// If window receives focus, delegate to first child.
			me.windowBase.Hwnd().
				GetNextDlgTabItem(win.HWND(0), false).
				SetFocus()
		}
	})

	me.windowBase.OnMsg().WmActivate(func(p wm.Activate) {
		// https://devblogs.microsoft.com/oldnewthing/20140521-00/?p=943
		if !p.IsMinimized() {
			if p.Event() == co.WA_INACTIVE {
				curFocus := win.GetFocus()
				if curFocus != 0 && me.windowBase.Hwnd().IsChild(curFocus) {
					me.childPrevFocus = curFocus // save previously focused control
				}
			} else if me.childPrevFocus != 0 {
				me.childPrevFocus.SetFocus() // put focus back
			}
		}
	})
}

func (me *WindowMain) runMainLoop() int32 {
	defer globalUiFont.Destroy()

	msg := win.MSG{}
	for {
		status := msg.GetMessage(win.HWND(0), 0, 0)
		if status == 0 {
			return int32(msg.WParam) // WM_QUIT was sent, gracefully terminate the program
		}

		if me.isModelessMsg(&msg) { // does this message belong to a modeless child (if any)?
			// http://www.winprog.org/tutorial/modeless_dialogs.html
			continue
		}

		// TODO haccel check !!!

		// If a child window, will retrieve its top-level parent.
		// If a top-level, use itself.
		if msg.HWnd.GetAncestor(co.GA_ROOT).IsDialogMessage(&msg) {
			// Processed all keyboard actions for child controls.
			continue
		}

		msg.TranslateMessage()
		msg.DispatchMessage()
	}
}

func (me *WindowMain) isModelessMsg(msg *win.MSG) bool {
	for _, hChild := range me.modelessChildren { // check all modeless HWNDs
		if hChild == 0 || !hChild.IsWindow() {
			continue // skip invalid HWND
		}
		if hChild.IsDialogMessage(msg) {
			return true // it was a message for this modeless, it was processed and we're done
		}
	}
	return false // the message wasn't for any of the modeless HWNDs
}

//------------------------------------------------------------------------------

type windowMainSetup struct {
	wasInit bool // default to false

	ClassName        string      // Optional, defaults to a hash generated by WNDCLASSEX parameters. Passed to RegisterClassEx.
	ClassStyle       co.CS       // Window class style, passed to RegisterClassEx.
	HIcon            win.HICON   // Icon associated with the window, passed to RegisterClassEx.
	HCursor          win.HCURSOR // Window cursor, passed to RegisterClassEx.
	HBrushBackground win.HBRUSH  // Window background brush, passed to RegisterClassEx.
	HIconSmall       win.HICON   // Small icon associated with the window, passed to RegisterClassEx.

	Title   string    // The title of the window, passed to CreateWindowEx.
	Width   uint32    // Initial width of the window, passed to CreateWindowEx.
	Height  uint32    // Initial height of the window, passed to CreateWindowEx.
	Style   co.WS     // Window style, passed to CreateWindowEx.
	ExStyle co.WS_EX  // Window extended style, passed to CreateWindowEx.
	HMenu   win.HMENU // Main window menu, passed to CreateWindowEx.

	CmdShow co.SW // Passed to ShowWindow, defaults to SW_SHOW.
}

func (me *windowMainSetup) initOnce() {
	if !me.wasInit {
		me.wasInit = true

		me.ClassStyle = co.CS_DBLCLKS

		me.Width = 600 // arbitrary dimensions
		me.Height = 500
		me.Style = co.WS_CAPTION | co.WS_SYSMENU | co.WS_CLIPCHILDREN | co.WS_BORDER
		me.ExStyle = co.WS_EX(0)

		me.CmdShow = co.SW_SHOW
	}
}

func (me *windowMainSetup) genWndClassEx(hInst win.HINSTANCE) *win.WNDCLASSEX {
	wcx := win.WNDCLASSEX{}

	wcx.CbSize = uint32(unsafe.Sizeof(wcx))
	wcx.HInstance = hInst
	wcx.Style = me.ClassStyle
	wcx.HIcon = me.HIcon
	wcx.HIconSm = me.HIconSmall

	if me.HCursor != 0 { // user specified a cursor
		wcx.HCursor = me.HCursor
	} else {
		wcx.HCursor = win.HINSTANCE(0).LoadCursor(co.IDC_ARROW)
	}

	if me.HBrushBackground != 0 { // user specified a background brush
		wcx.HbrBackground = me.HBrushBackground
	} else {
		wcx.HbrBackground = win.CreateSysColorBrush(co.COLOR_BTNFACE)
	}

	if me.ClassName == "" { // user left class name blank
		me.ClassName = wcx.Hash() // generate hash after all other fields are set
	}
	wcx.LpszClassName = win.StrToPtr(me.ClassName)

	return &wcx
}
